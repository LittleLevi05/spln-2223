<h1 style="font-size:60px" align="center"><img height=28cm src="https://raw.githubusercontent.com/LittleLevi05/spln-2223/main/TP2/images/logo.png"> HShield</h1>

<h4 align="center">A ferramenta ideal para anonimiza√ß√£o de dados pessoais dos seus documentos</h4>

<br>

<img src="https://raw.githubusercontent.com/LittleLevi05/spln-2223/main/TP2/images/banner.png">

<br>

1. [üåü Introdu√ß√£o](#introducao)
   1. [Contexto](#contexto)
   2. [Prop√≥sito e Objetivos](#proposito-e-objetivos)
2. [‚öôÔ∏è Caracteriza√ß√£o do sistema](#caracteriza√ß√£o-do-sistema)
   1. [Arquitetura](#arquitetura)
   2. [Anonimiza√ß√£o de Nomes](#anonimiza√ß√£o-de-nomes)
   3. [Anonimiza√ß√£o de Endere√ßos](#anonimiza√ß√£o-de-endere√ßos)
   4. [Anonimiza√ß√£o de Documentos](#anonimiza√ß√£o-de-documentos)
3. [üëã Modos de Uso](#modos-de-uso)
4. [üë• Equipa](#equipa)

## üåü Introdu√ß√£o

### Contexto

A privacidade de um indiv√≠duo est√° intimamente ligada aos seus dados. Dados os quais, nos dias de hoje, s√£o gerados numa quantidade nunca antes vista atrav√©s da Internet. Estas dados, quando n√£o s√£o cuidadosamente tratados, podem afetar a seguran√ßa das pessoas. Neste segmento que surge o conceito de anonimiza√ß√£o dos dados.

Uma defini√ß√£o conceptual da anonimizacÃßaÃÉo de dados pode ser ["para anonimizar quaisquer dados, t√™m de lhes ser retirados elementos suficientes para que deixe de ser poss√≠vel identificar (de forma irrevers√≠vel) o titular dos dados"](https://www.uc.pt/protecao-de-dados/protecao-de-dados-pessoais/anonimizacao-e-pseudonimizacao/) 
. Neste contexto surge o Regulamento Geral de Prote√ß√£o de Dados (RGPD), como tabm√©m a A Lei Geral de Prote√ß√£o de Dados Pessoais (LGPD) que define um [dado anonimizado  aquele que, originariamente, era relativo a uma pessoa, mas que passou por etapas que garantiram a desvincula√ß√£o dele a essa pessoa](https://www.serpro.gov.br/lgpd/menu/protecao-de-dados/dados-anonimizados-lgpd). Conforme a LGPD, [alguns exemplos de dados pessoais s√£o: nome, CPF, e-mail, idade, profiss√£o, foto, entre outros](https://blog.hosts.green/dados-anonimizados/).

### Prop√≥sito e Objetivos

O prop√≥sito deste projeto √© garantir a anonimiza√ß√£o dos dados sens√≠veis pessoais presentes em documentos. Assim, o seu objetivo √© concretizar um *software* que realiza uma s√©rie de tratamento de dados por forma a desvincular os dados das pessoas identificadas por eles. Este tratamento de dados resultar√° numa convers√£o de um dado documento numa vers√£o sua anonimizada. Dentre as diversas formas de dados pessoais existentes, foram consideradas: o nome das pessoas/organiza√ß√µes, endere√ßos (f√≠sicos ou na Web) e n√∫meros identificadores de documentos (como o CC, carta de condu√ß√£o, entre outros).

Em suma, o objetivo principal do sistema √© garantir a seguran√ßa dos ind√≠viduos atrav√©s de processos de anonimiza√ß√£o. Uma vez que existem diversas formas de se concretizar esta tarefa, [n√£o havendo um processo √∫nico de anonimiza√ß√£o, a solu√ß√£o ideal ser√° a que apresente em cada processo a maior impossibilidade da ‚Äúre-identifica√ß√£o dos titulares dos dados‚Äù. Por princ√≠pio, a anonimiza√ß√£o deveraÃÅ ser um processo irrevers√≠vel, an√°logo aÃÄ destrui√ß√£o.](https://www.uc.pt/protecao-de-dados/protecao-de-dados-pessoais/anonimizacao-e-pseudonimizacao/)


## ‚öôÔ∏è Caracteriza√ß√£o do sistema

### Arquitetura

 <img src="https://raw.githubusercontent.com/LittleLevi05/spln-2223/main/TP2/images/arq.png" alt="Alex">

### Anonimiza√ß√£o de Nomes


Os **nomes** anonimizados nesta etapa da ferramenta consistem em:

* **Nomes de Pessoas**: nomes pr√≥prios, apelidos, alcunhas. Por exemplo: *Jo√£o Pedro*, *Juliana*.
* **Nomes de Organiza√ß√µes**: nomes de entidades estruturadas, geralmente composta por um grupo de pessoas, que trabalha para atingir objetivos espec√≠ficos. Por exemplo: *Petrobras*, *Banco do Brasil*.

Para a anonimiza√ß√£o destes nomes foi decidido que, ao serem identificados, deviam ser substitu√≠dos pelas correspondentes iniciais intercaladas com o **ponto final**. Mas **n√£o somente isso**, uma vez que poderia haver a problem√°tica de nomes diferentes corresponderem as mesmas iniciais. Ora, uma coisa √© anonimizar um texto, outra √© fazer ele **perder o sentido e coes√£o**. N√£o pretendemos causar a perda de significado no texto, isto √©, deve ser poss√≠vel continuar a l√™-lo sem deixar de compreend√™-lo. O seguinte texto √© um exemplo disto: 

```
Jos√© Pedro esteve na Pra√ßa dos Arsenalistas naquela tarde. Quando Jos√© Pedro
encontrou Jo√£o Pinto, j√° era tarde demais. Jo√£o Pinto estava morto diante de Jos√© Pedro.
A partir deste dia a vida de Jos√© Pedro nunca foi a mesma, nem Joana Pedrosa (sua parceira
de trabalho no Banco do Brasil) acreditava mais nele.
```

Reparemos que as tr√™s entidades neste texto possuem as mesmas iniciais. Se os seus nomes apenas fossem substitu√≠dos pelas respectivas iniciais intercaladas com ponto, ent√£o ter√≠amos uma frase do tipo:

```
Quando J.P encontrou J.P, j√° era tarde demais.
```

A compreens√£o da frase **foi comprometida** e, por tanto, um cuidado adicional deve ser tomado. Esse cuidado consiste justamente em adicionar um **identificador** num√©rico as entidades, por forma a, quando for decteado o Jos√© Pedro, seja poss√≠vel distingui-lo do Jo√£o Pinto. Este identificador, ao ser adicionado na anonimiza√ß√£o, torna o texto do seguinte modo:

```
J.P(0) esteve na Pra√ßa dos Arsenalistas naquela tarde. Quando J.P(0)
encontrou J.P(1), j√° era tarde demais. J.P(1) estava morto diante de J.P(0).
A partir deste dia a vida de J.P(0) nunca foi a mesma, nem J.P(2) (sua parceira
de trabalho no B.d.B(0)) acreditava mais nele.
```

Como pode ser visto, sem revelar a identidade de nenhuma entidade, consegue-se agora compreender a natureza do significado das frases.

A metodologia do algoritmo geral para anonimiza√ß√£o dos nomes baseou-se ent√£o em tr√™s etapas:

1.  Detec√ß√£o das entidades do texto.
2.  Filtragem das entidades que representam **pessoas** e **organiza√ß√µes**;
3.  Calculo do identificador das entidades filtradas;
3. Substitui√ß√£o do nome destas entidades pelo seu nome anonimizado com o identificador.

A etapa 1 e 2 foram concretizadas utilizando a biblioteca Spacy. Ap√≥s carregar o modelo de processamento de texto no idioma do texto dado pelo utilizador e aplicar os processamentos lingu√≠sticos deste modelo no texto, √© poss√≠vel extrair as suas entidades da seguinte maneira:

```Python
nlp = spacy.load('en_core_web_sm')
doc = nlp(self.text)
for ent in doc.ents:
    if ent.label_ == "PERSON" or ent.label_ == "ORG":
        # substitution
```

Por outro lado, a etapa 3 e 4 foram realizadas com t√©cnicas de processamento de texto em Python, utilizando alguns m√©todos sobre *strings* e o m√≥dulo RE para express√µes regulares. Dada uma entidade, os seus respectivos nomes foram separados a partir de um ou mais car√°cter de espa√ßo em branco e, de seguida, o **nome anonimizado**  foi formado com as iniciais de cada nome concatenadas com o car√°cter **"."**. Inicialmente, foi utilizada a fun√ß√£o *split* sobre *strings* com um √∫nico delimitador de "espa√ßo" para serem separados os nomes de uma entidade. Por√©m, esta alternativa n√£o foi seguida, uma vez que alguns textos mal formados poderiam conter mais de um car√°cter de espa√ßo em branco entre os nomes de uma entidade. Por isso que, como pode ser visto no excerto de c√≥digo seguinte, foi utilizado o *split* do m√≥dulo RE que possibilitar a utiliza√ß√£o de uma express√£o regular para informar o delimitador do *split*.

```Python
if ent.label_ == "PERSON" or ent.label_ == "ORG":
    ent_names = re.split(r"\s+",ent.text)
    anonymized_name = ".".join(name[0] for name in ent_names)
```

Como foi exemplicado anteriormente, este termo *anonymized_name* ainda n√£o est√° completo. Falta a adi√ß√£o do identificador da entidade. Para isto foi criado um dicion√°rio chamado *dic_names*. Seu objetivo √© relacionar, para cada valor de letras iniciais intercaladas com ponto (*anonymized_name* sem identificador) os nomes das entidades 
que utilizam tais letras iniciais de forma id√™ntica. Por outras pavras, no caso do exemplo anterior, este dicion√°rio teria:

```
dic_names = {
  "J.P" = ["Jos√© Pedro", "Jo√£o Pinto", "Joana Pedrosa"]
}
```

Deste modo, foi decidido que o identificador de cada entidade
seria justamente a sua posi√ß√£o na lista de nomes do seu nome anonimizado. Da√≠ resulta no Jos√© Pedro ser o J.P(0), o Jo√£o Pinto ser o J.P(1) e a Joana Pedrosa a J.P(2). O algoritmo que efetua o calculo do identificador √© o seguinte:

```Python
if anonymized_name in dic_names:
    if ent.text in dic_names[anonymized_name]:
        id = dic_names[anonymized_name].index(ent.text)
    else:
        id = len(dic_names[anonymized_name])
        dic_names[anonymized_name].append(ent.text)
else:
    id = 0
    dic_names[anonymized_name] = [ent.text]
```

 Uma vez em posse do nome anonimizado com o seu identificador, bastava substituir todas as ocorr√™ncias do nome sem anonimiza√ß√£o pelo termo anonimizado. 
 
 ```
 anonymized_name += '('+str(id)+')'
self.text = re.sub(ent.text,anonymized_name,self.text)   
 ```

### Anonimiza√ß√£o de Endere√ßos

### Anonimiza√ß√£o de Documentos
Os documentos anonimizados s√£o identificados atrav√©s de uma express√£o regular. De seguida, s√≥ √© realizada a anonimiza√ß√£o se na prefiria do formato identificado for encontrada pelo menos uma keyword associada ao documento.

A associa√ß√£o do formato do documento e das keywords permite aumentar o contexto dispon√≠vel para tomar a decis√£o se a anonimiza√ß√£o est√° correta. 
Considere-se o caso espec√≠fico de um n√∫mero de telem√≥vel com 9 d√≠gitos e o n√∫mero de identifica√ß√£o fiscal (NIF). Ambos t√™m o mesmo formato, 9 d√≠gitos seguidos sem espa√ßos. Se na preferia do formato encontrado se encontrar a keyword "nif" h√° uma maior confian√ßa que o formato encontrado √© de facto um NIF. Se, por outro lado, se encontrar uma keyword "ligar" h√° uma maior confian√ßa que o formato encontrado √© um n√∫mero de telem√≥vel. 
No entanto, √© necess√°rio um jogo de balanceamento, uma vez que n√£o se pretende pesquisar numa preferia muito grande, onde o contexto se ia tornar muito abrangente, mas tamb√©m n√£o se pretende ter uma preferia muito pequena.
A figura seguinte permite encontrar um exemplo onde uma preferia muito grande poderia levar a resultados errados. 

```
A Carla est√° sempre a avisar para eu n√£o me esquecer de adicionar o nif do clube, sempre que fa√ßo 
despesas com a carrinha do clube. O problem √© que j√° me esqueci, sabes qual √© o nif? 
Sim, √© 123456789, mas o melhor era ligares para confirmar. O n√∫mero de telem√≥vel dela √© o 912345678
Obrigado! Vou ver se lhe ligo assim que conseguir. 
```

Neste caso, se a preferia fosse muito abrangente, ao identificar "912345678" ia-se encontrar a keyword "nif" e haveria um falso positivo. 
Por outro lado, se a preferia fosse muito pequena, por exemplo mais ou menos duas palavras, n√£o se identificaria a keyword "ligar" e haveria um falso negativo. 

Este problema poderia ser resolvido se se assumisse que se fizesse duas pesquisas. 
Uma da express√£o identificada para o in√≠cio do texto e da express√£o para o fim do texto.
Desta forma a keyword mais pr√≥xima era que seria "encontrada" primeiro. 

A raz√£o pela qual foi estabelicido um limite nesta janela de procura era o overhead de procurar no texto todo. 
Na verdade, √© comum encontrar-se estas keywords perto da express√£o encontrada e quanto mais afastada estiver a keyword menos confian√ßa se tem que realmente a express√£o √© a que mapeia o tipo de documento que se est√° a procurar no momento.

#### Utiliza√ß√£o spacy
Assim que se obtem o texto √© criado o documento spacy do texto. A raz√£o para utilzar o spacy √© porque desta forma √© poss√≠vel fazer uma lemaliza√ß√£o da janela de contexto, e pesquisar pelo lema de uma keyword nesta janela com lemaliza√ß√£o. A vantagem de fazer a lemiza√ß√£o √© a abrang√™ncia de mais palavras mapeadas na mesma keyword.
No exemplo seguinte pode-se encontrar uma palavra, ligou, que n√£o faria match com a palavra ligar. 

```
O Diogo ligou para o n√∫mero 912345678 da Carla. 
```

Considere-se a janela "ligou para o n√∫mero 912345678 da Carla.", ao realizar a lemaliza√ß√£o desta janela obt√©m-se
"Diogo ligar para o n√∫mero 912345678 de o Carla ." Desta forma a keyword "ligar" j√° consegue fazer match.

#### Algoritmo de anonimiza√ß√£o
Existem tr√™s passos na realiza√ß√£o da anonimiza√ß√£o. 

1. Parsing do ficheiro que cont√©m os documentos que se pretende identificar;
2. Para cada tipo de documento encontrar formatos que fa√ßam match no texto;
3. Para cada match encontrada verificar se existem keywords na janela de contexto. Se um tipo de documento tiver um algoritmo de check apenas subsituir se o check provar que o padr√£o √© v√°lido.

De seguida vai ser explorado cada passo em pormenor.

#### Estrutura do ficheiro de tipos documentos
O ficheiro cont√©m a identifica√ß√£o do pa√≠s onde os documentos s√£o emitidos. 
De seguida existe uma lista de documentos a serem identificados.
Cada documento cont√©m:
* um identificador do documento;
* o padr√£o onde deve constar uma express√£o regular do formato do documento;
* uma lista de keywords para permitir um maior contexto na identifica√ß√£o do documento;
* um booleano que identifica se o documento tem uma fun√ß√£o de check;
* um identificador que substitua o documento encontrado.

#### Encontrar os formatos dos v√°rios documentos
Para cada tipo de documento existente √© utilizada a fun√ß√£o `re.sub` com a express√£o regular do formato do documento,
com um m√©todo `change` respons√°vel pela verifica√ß√£o se o match vai ser anonimizado e por √∫ltimo o texto mais atual. 
Ou seja, se j√° houve anonimiza√ß√µes este texto vai cont√™-las.

#### Verifica√ß√£o da exist√™ncia de keywords na janela de contexto
O primeiro obst√°culo √© a cria√ß√£o da janela de contexto. 
A janela de contexto √© composta por tokens e est√° centrada no primeiro carat√©r de um match do carat√©r. 
Portanto √© necess√°rio saber qual o token que corresponde ao offset desse carat√©r no texto. 

```
"A Alice e o Bob est√£o a comunicar por um telefone estragado."
```

Neste exemplo se o match for "Alice" o offset do carat√©r 'A' vai ser utilizado para calcular qual o token vai ser utilizado 
para centrar a janela de contexto. Para tal percorre-se o documento spacy, token a token, e verifica-se a condi√ß√£o             
`token.idx <= offset < token.idx + len(token.text)`. Se for verdadeira ent√£o este token √© considerado o token central da janela. 
Neste exemplo a janela seria: `[A_token, Alice_token, e_token]`. De salientar que como o m√©todo `re.sub` faz uma travessia do texto
de forma sequencial do primeiro carat√©r para o √∫ltimo, sem saltos, √© poss√≠vel ir percorrendo o documento spacy na verifica√ß√£o da condi√ß√£o, inv√©s de 
estar sempre a percorrer o documento spacy. Para tal guarda-se o √∫ltimo √≠ndice do √∫ltimo token que foi o centro de uma janela. 

No entanto, esta verifica√ß√£o assume um offset do carat√©r em rela√ß√£o ao texto original, texto usado para criar o documento spacy.
Desta forma sempre que existe uma substitui√ß√£o, e consequente altera√ß√£o do texto original, √© inserido um par `(pos, delta)` numa lista de hist√≥rico.
Ao fazer match de uma express√£o de um texto, que n√£o o original, extrai-se o offset do primeiro carat√©r do match (com recurso ao m√©todo `match_object.start(0)`) 
e faz-se uma convers√£o de qual seria o offset no texto original. No caso de n√£o tiverem havido nenhuma substitui√ß√£o num carat√©r inferior 
ent√£o o offset obtido pelo o match √© equivalente ao do texto orignal. No entanto, se j√° houve √© necess√°rio fazer uma soma de deltas de substitui√ß√£o pr√©vias e substrair o delta acumulado.
 
Com a janela j√° criada, percorre-se token a token da janela e cria-se uma string de lemmas desses tokens separados por espa√ßos.
De seguida, para cada key nas keywords verifica-se se o lemma dessa key existe na string de lemas da janela. Se existir ent√£o a match pode eventualmente ser anonimizada.

#### Documentos com fun√ß√£o de check
H√° documentos que requerem uma fun√ß√£o de check. Para tal assume-se que existe uma fun√ß√£o com o nome "check_country_tipo_de_padrao" que devolve um booleano.
O exemplo a seguir demonstra um exemplo de um cart√£o de cidad√£o (CC) v√°lido e de outro inv√°lido, assim como as contas feitas para verificar se um CC √© valido.

```
TODO fazer exemplo 
```







## üëã Modos de Uso

A utiliza√ß√£o do programa HShield pode englobar tanto uma anonimiza√ß√£o global do documento de *input*, tanto como uma anonimiza√ß√£o especializada para algum termo-alvo. Disponibiliza-se assim op√ß√µes para serem anonimizados os (1) nomes, (2) documentos e (3) endere√ßos. Estas op√ß√µes podem ser utilizadas em conjunto, mediante a necessidade do utilizador.

```bash
Data anonymizer tool

positional arguments:
  filename

optional arguments:
  -h, --help            show this help message and exit
  -n, --name            anonymize only names
  -d, --document        anonymize only documents
  -a, --address         anonymize only addresses
  -o OUTPUT, --output OUTPUT
                        output file

Build by Henrique, Jos√© and Alex
```

## üë• Equipa

| ![Henrique Parola](https://raw.githubusercontent.com/LittleLevi05/spln-2223/main/TP2/images/henrique.jpeg) | ![Jos√© Pedro](https://raw.githubusercontent.com/LittleLevi05/spln-2223/main/TP2/images/jose.png) | ![Alex](https://raw.githubusercontent.com/LittleLevi05/spln-2223/main/TP2/images/alex.png) |
|:---:|:---:|:---:|
| Henrique Parola | Jos√© Pedro | Alex |